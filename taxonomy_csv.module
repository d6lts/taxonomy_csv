<?php
// $Id$

/**
 * Copyright (c) 2007-2008 Dennis Stevense, see LICENSE.txt for more information.
 * Copyright (c) 2009 Daniel Berthereau <daniel.drupal@berthereau.net>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License.
 */

/**
 * @file taxonomy_csv.module
 * Quick import of taxonomies or lists of terms with a csv file.
 *
 * Automatically imports a list of terms, children, related, synonyms,
 * descriptions and/or weights into a vocabulary with a simple csv file.
 */

define('TAXONOMY_CSV_IMPORT_IGNORE',           0);
define('TAXONOMY_CSV_IMPORT_CHILDREN',         1);
define('TAXONOMY_CSV_IMPORT_RELATIONS',        2);
define('TAXONOMY_CSV_IMPORT_SYNONYMS',         3);
define('TAXONOMY_CSV_IMPORT_DESCRIPTIONS',     4);
define('TAXONOMY_CSV_IMPORT_WEIGHTS',          5);

define('TAXONOMY_CSV_DELIMITER_COMMA',         0);
define('TAXONOMY_CSV_DELIMITER_SEMICOLON',     1);

define('TAXONOMY_CSV_DISABLE_CONVERT_TO_UTF8', FALSE);

define('TAXONOMY_CSV_EXISTING_IGNORE',         0);
define('TAXONOMY_CSV_EXISTING_UPDATE_REPLACE', 1);
define('TAXONOMY_CSV_EXISTING_UPDATE_MERGE',   2);

/**
 * Implementation of hook_help().
 */
function taxonomy_csv_help($path, $arg) {
  switch ($path) {
    case 'admin/content/taxonomy/csv':
      $output = '<p>'. t('Use this form to import a taxonomy or a list of terms into a vocabulary from a simple !link file.', array('!link' => l(t('CSV'), 'http://en.wikipedia.org/wiki/Comma-separated_values'))) .'</p>';
      $output .= '<p>'. t('<strong>Warning:</strong> If you want to update an existing vocabulary, make sure you have a backup before you proceed so you can roll back, if necessary.') . theme('more_help_link', url('admin/help/taxonomy_csv'));
      return $output;

    case 'admin/help#taxonomy_csv':
      $output = '<p>'. t('This module allows you to <a href="!import-url">import taxonomies or simple lists of terms</a> into a vocabulary from a <a href="http://en.wikipedia.org/wiki/Comma-separated_values" title="Wikipedia definition">CSV</a> file.', array('!import-url' => url('admin/content/taxonomy/csv'))) .'</p>';
      $output .= '<p>'. t('If you are unsure how to create a CSV file, you might want to use <a href="http://www.openoffice.org" title="OpenOffice.org">OpenOffice Calc</a> or another spreadsheet application to export your data into a CSV file.') .'</p>';
      $output .= '<p>'. t('You can choose how source will be imported and what existing terms will become.') .'</p>';
      $output .= '<p><strong>'. t('Source') .'</strong></p>';
      $output .= '<p>'. t('Source can be configured with the first field set. The term name will be imported from the first column. You can specify how additional columns should be imported:') .'</p>';
      $output .= '<dl><dt>'. t('Ignore') .'</dt><dd>'. t('This has the same effect has having a single column.') .'</dd>';
      $output .= '<dt>'. t('Child term names') .'</dt><dd>'. t('The second column will be imported as the name of a child term of the term defined by the first column. The third column will be imported as a child of the second column, and so on. For example, you might have a line <code>Animal,Mammal,Dog</code>.') .'</dd>';
      $output .= '<dd>'. t('Be careful: when a child is added or updated, line should contain all its ancestors. So a second line may be <code>Animal,Mammal,Human</code>, but <strong>not</strong> <code>Mammal,Human</code>, because in this second case, <code>Mammal</code> is imported as a first level term and not as a <code>Animal</code> term child as in previous line.') .'</dt>';
      $output .= '<dt>'. t('Related terms') .'</dt><dd>'. t('The second and next columns will be imported as related terms of the first column term. For example, a line may be: <code>Thesaurus,Taxonomy,Ontology</code>.') .'</dd>';
      $output .= '<dt>'. t('Synonyms terms') .'</dt><dd>'. t('The second and next columns will be imported as synonyms terms of the first column term. For example, a line may be: <code>"United Kingdom","UK","U.K."</code>.') .'</dd>';
      $output .= '<dt>'. t('Term description') .'</dt><dd>'. t('The second column will be imported as the term description of the first column term.') .'</dd>';
      $output .= '<dt>'. t('Term weights') .'</dt><dd>'. t('The second column will be imported as weight of the term defined by first column.') .'</dd></dl>';
      $output .= '<p><strong>'. t('Destination') .'</strong></p>';
      $output .= '<p>'. t('Destination can be configured with the second field set. You can specify what will become existing terms. Three choices are possible:') .'</p>';
      $output .= '<dl><dt>'. t('Update terms and merge existing') .'</dt><dd>'. t('Update current terms when name matches with imported ones and merge existing descriptions, parents, synonyms and related terms with new ones. Duplicates are removed. This choice is recommended if you want to keep a vocabulary and if you have descriptions, parents, synonyms and related terms you don\'t want to lose.') .'</dd>';
      $output .= '<dt>'. t('Update terms and replace existing') .'</dt><dd>'. t('Update current terms if name matches, but remove existing descriptions, parents, synonyms and related terms. Choose this option if you are want to create a clean new vocabulary without losing existing terms.') .'</dd>';
      $output .= '<dd>'. t('Be careful: if there is no description, parent, synonym or related term, i.e. the line contains only a term in the first column, this removes the existing.') .'</dd>';
      $output .= '<dt>'. t('Ignore current terms and create new ones') .'</dt><dd>'. t('Let current terms as they are and create totally new terms.') .'</dd><dd>'. t('Warning: This can create duplicate terms. It is recommended to use this option only if you are sure that imported taxonomy contains only new terms or if your vocabulary allows multiple parents.') .'</dd></dl>';
      $output .= '<p>'. t('When you want to import child term names as well as descriptions, synonyms, related terms and term weights, you should begin with the file containing the hierarchical structure of parent and child. So first import child term names with the <em>Child term names</em> option. Second, upload the other files with the adequate option and one of the <em>Update terms...</em> option.') .'</p>';
      $output .= '<p>'. t('Be careful: if 1) source choice is <strong>not</strong> <em>"Ignore"</em> additional columns, 2) file or a line in the file has only one column and 3) you choose <em>"Update and replace"</em>, the import process will be a remove process of matching items (first column terms are always kept or imported).') .'</p>';
      $output .= '<p>'. t('It is recommended to protect terms with quotation marks (<strong><code>"</code></strong>), specialy if they contain non-ASCII letters or if imported items, in particular descriptions, contain the chosen delimiter: <code>"term 1","term 2","term 3"</code>.') .'</p>';
      $output .= '<p>'. t('Delimiters (comma "<strong><code>,</code></strong>" or semicolon "<strong><code>;</code></strong>") between terms can be chosen in Advanced settings.') .'</p>';
      $output .= '<p>'. t('Another Drupal module allows CSV import too, despite its name: <a href="http://drupal.org/project/taxonomy_xml" title="taxonomy XML">taxonomy XML</a>. Its approach is different: it uses one file complient to thesauri standard ISO 2788, i.e. a three columns csv file: <code>first term, type of link, second term</code>, or, for specialists, <code>subject, predicate, object</code>. So choose the module best matching your needs.') .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 */
function taxonomy_csv_menu() {
  $items = array();

  $items['admin/content/taxonomy/csv'] = array(
    'title' => 'CSV import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_csv_import'),
    'access arguments' => array('administer taxonomy'),
    'weight' => 12,
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Generates the taxonomy CSV import form.
 *
 * Form contain two fields: first for configuring Source (what to import),
 * second for configuring Destination (where to import and what will become
 * existing terms).
 *
 */
function taxonomy_csv_import() {
  $vocabularies = taxonomy_get_vocabularies();

  if (empty($vocabularies)) {
    $form['warning'] = array('#type' => 'fieldset', '#title' => t('<strong>None vocabulary found!</strong>'));

    $form['warning']['no_vocabulary'] = array(
      '#prefix' => '<p>',
      '#suffix' => '</p>',
      '#value' => t('None vocabulary has been found. You need one in order to import your terms into. So you need to !add-new-vocab before to use this module.', array('!add-new-vocab' => l(t('add a new vocabulary'), 'admin/content/taxonomy/add/vocabulary', array('query' => drupal_get_destination())))),
    );
  }
  else {
    $form = array('#attributes' => array(
      'enctype' => 'multipart/form-data')
    );
    $form['source'] = array(
      '#type' => 'fieldset',
      '#title' => t('Source')
    );

    $form['source']['upload'] = array(
      '#type' => 'file',
      '#title' => t('CSV file'),
    );

    if ($max_size = _taxonomy_csv_parse_size(ini_get('upload_max_filesize'))) {
      $form['source']['upload']['#description'] = t('Due to server restrictions, the maximum upload file size is !size. Files that exceed this size will be disregarded without notice.', array('!size' => format_size($max_size)));
    }

    $form['source']['columns'] = array(
      '#type' => 'radios',
      '#title' => t('Additional columns'),
      '#options' => array(
        TAXONOMY_CSV_IMPORT_IGNORE => t('Ignore'),
        TAXONOMY_CSV_IMPORT_CHILDREN => t('Child term names'),
        TAXONOMY_CSV_IMPORT_RELATIONS => t('Related terms'),
        TAXONOMY_CSV_IMPORT_SYNONYMS => t('Synonyms terms'),
        TAXONOMY_CSV_IMPORT_DESCRIPTIONS => t('Term descriptions'),
        TAXONOMY_CSV_IMPORT_WEIGHTS => t('Term weights'),
      ),
      '#default_value' => TAXONOMY_CSV_IMPORT_IGNORE,
      '#required' => TRUE,
      '#description' => t('The first column is always imported as the term name. This option determines how additional columns will be imported. Children (structure of vocabulary) should be imported first when multiple files are imported.'),
    );

    $form['source']['advanced'] = array(
       '#type' => 'fieldset',
       '#title' => t('Advanced settings'),
       '#collapsible' => TRUE,
       '#collapsed' => TRUE,
    );

    $form['source']['advanced']['delimiter'] = array(
      '#type' => 'radios',
      '#title' => t('CSV file delimiter'),
      '#options' => array(
        TAXONOMY_CSV_DELIMITER_COMMA => t('Comma " <strong><code>,</code></strong> "'),
        TAXONOMY_CSV_DELIMITER_SEMICOLON => t('Semicolon " <strong><code>;</code></strong> "'),
      ),
      '#default_value' => TAXONOMY_CSV_DELIMITER_COMMA,
      '#description' => t('Choose the delimiter used in the CSV file you want to import.'),
    );

    $form['source']['advanced']['disable_convert_to_utf8'] = array(
      '#type' => 'checkbox',
      '#title' => t('Disable file conversion because the csv file is already UTF-8 encoded'),
      '#default_value' => TAXONOMY_CSV_DISABLE_CONVERT_TO_UTF8,
      '#description' => t('This checkbox disables the conversion of the CSV file to UTF-8, what can be a cause of problems with some rare server configurations. Be sure your file is UTF-8 encoded when using this option.'),
    );

    $form['dest'] = array(
      '#type' => 'fieldset',
      '#title' => t('Destination'),
    );

    $form['dest']['vid'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary'),
      '#options' => array(),
      '#required' => TRUE,
      '#description' => t('The vocabulary you want to import the file into. You might want to !add-new-vocab.', array('!add-new-vocab' => l(t('add a new vocabulary'), 'admin/content/taxonomy/add/vocabulary', array('query' => drupal_get_destination())))),
    );

    foreach ($vocabularies as $vid => $vocabulary) {
      $form['dest']['vid']['#options'][$vid] = $vocabulary->name;
    }

    $form['dest']['update'] = array(
      '#type' => 'radios',
      '#title' => t('Existing terms'),
      '#options' => array(
        TAXONOMY_CSV_EXISTING_UPDATE_MERGE => t('Update terms and merge existing items'),
        TAXONOMY_CSV_EXISTING_UPDATE_REPLACE => t('Update terms and replace existing items'),
        TAXONOMY_CSV_EXISTING_IGNORE => t('Ignore current terms and create new ones'),
      ),
      '#default_value' => TAXONOMY_CSV_EXISTING_UPDATE_REPLACE,
      '#required' => TRUE,
      '#description' => t('<p>Whether existing terms with the same name should be updated or ignored.</p>
      <p>For example, if existing related terms of term <code>"Drupal"</code> are: <code>"Free"</code> and <code>"Open source"</code> and an imported line in the csv file is <code>"Drupal","knowledge management"</code>, then:
      <dt><dd><em>"Update and merge"</em> choice make related terms of <code>"Drupal"</code> are now <code>"Free"</code>, <code>"Open source"</code> and <code>"knowledge management"</code>;</dd>
      <dd><em>"Update and replace"</em> choice make related term of <code>"Drupal"</code> is now only <code>"knowledge management"</code>;</dd>
      <dd><em>"Ignore and create"</em> choice make two <code>"Drupal"</code> terms, one with existing related and other items and another one with only the imported related term <code>"knowledge management"</code>.</dd></dt></p>'),
    );

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Import'),
    );
  }

  return $form;
}

/**
 * Parses PHP configuration size values into bytes.
 *
 * @param $value
 *   A value to convert in bytes
 * @return $number
 *   The value in bytes
 *
 * Edited from an example at http://php.net/manual/en/function.ini-get.php
 */
function _taxonomy_csv_parse_size($value) {
  $value = trim($value);
  $number = (int)substr($value, 0, -1);

  $suffix = strtoupper(substr($value, -1));
  switch ($suffix) {
    case 'T':
      $number *= 1024;

    case 'G':
      $number *= 1024;

    case 'M':
      $number *= 1024;

    case 'K':
      $number *= 1024;
      break;

    default:
      $number = $value;
  }
  return $number;
}

/**
 * Handles CSV import form validation.
 */
function taxonomy_csv_import_validate($form, &$form_state) {
  $form_state['upload_file'] = file_save_upload('upload');
  if (!$form_state['upload_file']) {
    form_set_error('upload', t('Please upload a file.'));
  }
}

/**
 * Handles CSV import form submission and prepare batch set.
 */
function taxonomy_csv_import_submit($form, &$form_state) {
  $options = $form_state['values'];

  $file = $form_state['upload_file'];

  if ($options['delimiter'] == TAXONOMY_CSV_DELIMITER_SEMICOLON) {
    $delimiter = ';';
  }
  else {
    $delimiter = ',';
  }

  $options['vocabulary'] = taxonomy_vocabulary_load($options['vid']);

  // Automatically detect line endings.
  ini_set('auto_detect_line_endings', '1');

  $handle = fopen($file->filepath, 'r');
  $batch = array(
    'operations' => array(),
    'finished' => 'taxonomy_csv_import_finished',
    'title' => t('Importing terms from CSV file'),
    'init_message' => t('Starting import...'),
    'progress_message' => t('Imported @current out of @total lines.'),
    'error_message' => t('An error occurred during the import.'),
  );
  $first = TRUE;
  while ($line = fgetcsv($handle, 4096, $delimiter)) {
    if (empty($line) || (count($line) == 1 && $line[0] == NULL)) continue;

    // Skip UTF-8 byte order mark.
    if ($first) {
      if (strncmp($line[0], "\xEF\xBB\xBF", 3) === 0) {
        $line[0] = substr($line[0], 3);
        $first = FALSE;
      }
    }

    // Encode the line in base64 to prevent batch errors for weird encodings.
    $batch['operations'][] = array('taxonomy_csv_import_line', array(array_map('base64_encode', $line), $options));
  }
  fclose($handle);

  batch_set($batch);
}

/**
 * Callback for finished batch import.
 */
function taxonomy_csv_import_finished($success, $results, $operations) {
  drupal_set_message(t('The CSV file has been imported.'));
}

/**
 * Import a line that contains a term and other items matching the submit options.
 *
 * @param $line
 *   Array which contains a line of imported csv file.
 * @param $options
 *   Array of submit options
 * @return
 *   Currently none.
 */
function taxonomy_csv_import_line($line, $options) {
  // Decode the line.
  $line = array_map('base64_decode', $line);

  // Convert line to UTF-8.
  // No convert if it's already utf-8: corrects bug http://drupal.org/node/364832.
  if (!$options['disable_convert_to_utf8']) {
    $line = array_map('_taxonomy_csv_import_line_to_utf8', $line);
  }

  // Code is currently not factorized.
  switch ($options['columns']) {
    case TAXONOMY_CSV_IMPORT_CHILDREN:
      //first column: root ancestor.
      $parent = 0;
      for ($c = 0; $c < count($line); $c++) {
        if (!empty($line[$c])) {

          $term = array(
            'name' => $line[$c],
            'vid' => $options['vid'],
            // Need an array in order to merge, even if it is the only parent.
            // So Parent [0] matches the current parent for line import.
            'parent' => array($parent),
          );

          // Currently, keep previous import system for children, so no merge.
          if ($option['update'] == TAXONOMY_CSV_EXISTING_UPDATE_MERGE) {
            $option['update'] = TAXONOMY_CSV_EXISTING_UPDATE_REPLACE;
          }

          // Parent terms (so all terms but the last on this line) are always updated because they are successive parents of a child.
          $term = taxonomy_csv_import_term($term, (($options['update'] == TAXONOMY_CSV_EXISTING_IGNORE) and ($c < count($line) - 1)) ? TAXONOMY_CSV_EXISTING_UPDATE_REPLACE : $options['update']);
          $parent = $term['tid'];
        }
      }
      break;

    case TAXONOMY_CSV_IMPORT_RELATIONS:
      if (!empty($line[0])) {
        $term = array(
          'name' => $line[0],
          'vid' => $options['vid'],
        );

        // Each related term should exist before it can be related (need of its tid).
        $term['relations'] = array();
        $related_names = array_unique(array_filter(array_slice($line, 1)));
        foreach ($related_names as $related_name) {
          $related_term = array(
            'name' => $related_name,
            'vid' => $options['vid'],
          );
          $related_term = taxonomy_csv_import_term($related_term, $options['update']);
          $term['relations'][] = $related_term['tid'];
        }

        taxonomy_csv_import_term($term, $options['update']);
      }
      break;

    case TAXONOMY_CSV_IMPORT_SYNONYMS:
      if (!empty($line[0])) {
        $term = array(
          'name' => $line[0],
          'vid' => $options['vid'],
          'synonyms' => array_unique(array_filter(array_slice($line, 1))),
        );

        taxonomy_csv_import_term($term, $options['update']);
      }
      break;

    case TAXONOMY_CSV_IMPORT_DESCRIPTIONS:
      if (!empty($line[0])) {
        $term = array(
          'name' => $line[0],
          'vid' => $options['vid'],
          'description' => $line[1],
        );

        taxonomy_csv_import_term($term, $options['update']);
      }
      break;

    case TAXONOMY_CSV_IMPORT_WEIGHTS:
      if (!empty($line[0])) {
        $term = array(
          'name' => $line[0],
          'vid' => $options['vid'],
          'weight' => $line[1],
        );

        taxonomy_csv_import_term($term, $options['update']);
      }
      break;

    case TAXONOMY_CSV_IMPORT_IGNORE:
      if (!empty($line[0])) {
        $term = array(
          'name' => $line[0],
          'vid' => $options['vid'],
        );

        taxonomy_csv_import_term($term, $options['update']);
      }
      break;
  }
}

/**
 * Helper function to convert a line of text to UTF-8.
 */
function _taxonomy_csv_import_line_to_utf8($value) {
  $enc = mb_detect_encoding($value, 'UTF-8, ISO-8859-1, ISO-8859-15', TRUE);
  if ($enc != 'UTF-8') {
    $value = drupal_convert_to_utf8($value, $enc);
  }
  return $value;
}

/**
 * Update or create a term with the given name in the given vocabulary and
 * given parent.
 *
 * @param $term
 *   A term array to import. Term is an array containing: (
 *     'name' => term name string,
 *     'vid' => the vocabulary id where to import,
 *   and eventually, matching submit options,
 *     'parent' => array of all first level parent tids,
 *     'relations' => array of related tids,
 *     'synonyms' => array of synonyms terms names strings,
 *     'description' => description string,
 *     'weight' => weight integer,
 *   )
 *   Parent [0] matches the current parent where to import.
 * @param $update
 *   Optional. The way to import: update and merge, update and replace (default)
 *   or ignore and create.
 * @return $term
 *   Imported term array. Empty array if no imported term.
 */
function taxonomy_csv_import_term($term, $update = TAXONOMY_CSV_EXISTING_UPDATE_REPLACE) {
  if (!empty($term)) {
    if ($update != TAXONOMY_CSV_EXISTING_IGNORE) {
      if ($existing_term = taxonomy_csv_find_term($term['name'], $term['vid'], isset($term['parent'][0]) ? $term['parent'][0] : NULL)) {
        switch ($update) {
          // Code currently not factorized.
          case TAXONOMY_CSV_EXISTING_UPDATE_MERGE:
            if (isset($term['relations'])) {
              $existing_term['relations'] = array_unique(array_merge($existing_term['relations'], $term['relations']));
            }
            if (isset($term['synonyms'])) {
              $existing_term['synonyms'] = array_unique(array_merge($existing_term['synonyms'], $term['synonyms']));
            }
            if (isset($term['description'])) {
              $existing_term['description'] = trim($existing_term['description']);
              if ($existing_term['description'] != $term['description']) {
                $existing_term['description'] .= "\n" . $term['description'];
              }
            }
            // Weight is always updated as it is a simple number.
            if (isset($term['weight'])) {
              $existing_term['weight'] = $term['weight'];
            }
            break;

          case TAXONOMY_CSV_EXISTING_UPDATE_REPLACE:
            foreach (array('relations', 'synonyms', 'description', 'weight') as $key) {
              if (array_key_exists($key, $term)) {
                $existing_term[$key] = $term[$key];
              }
            }
            break;

          }
        $term = $existing_term;
      }
    }

    // Drupal taxonomy_save_term use a text area format to import synonyms.
    if (isset($term['synonyms'])) {
      $synonyms = $term['synonyms'];
      $term['synonyms'] = implode("\n", $term['synonyms']);
    }

    taxonomy_save_term($term);

    // Keep synonyms as an array.
    if (isset($synonyms)) {
      $term['synonyms'] = $synonyms;
    }

    return $term;
  }
}

/**
 * Find, by its name, the first existing term in a given vocabulary and a given
 * parent.
 *
 * @param $name
 *   The name string to find.
 * @param $vid
 *   The vocabulary id where to search.
 * @param $parent
 *   Optional. The parent term id if any.
 * @return
 *   Found term array as describe in taxonomy_csv_import_term or an empty array.
 */
function taxonomy_csv_find_term($name, $vid, $parent = NULL) {
  $name = drupal_strtolower(trim($name));

  $sql = "SELECT t.tid, t.*, h.parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE '%s' LIKE LOWER(t.name) AND t.vid = %d ";
  $args = array($name, $vid);
  if (!is_null($parent)) {
    $sql .= "AND h.parent = %d ";
    $args[] = $parent;
  }
  $sql .= "LIMIT 1 ";

  $result = db_query($sql, $args);
  $term = db_fetch_array($result);

  if (!empty($term['tid'])) {
    $term['relations'] = _taxonomy_csv_get_related_ids($term['tid']);
    $term['synonyms'] = taxonomy_get_synonyms($term['tid']);
  }
  else {
    $term = array();
  }
  return $term;
}

/**
 * Return an array of all term IDs related to a given term ID.
 */
function _taxonomy_csv_get_related_ids($tid) {
  $related_ids = array();
  if (!empty($tid)) {
    if ($related_terms = taxonomy_get_related($tid)) {
      foreach ($related_terms as $term => $item) {
        $related_ids[] = $related_terms[$term]->tid;
      }
    }
  }
  return $related_ids;
}
