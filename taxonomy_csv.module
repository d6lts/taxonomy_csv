<?php
// $Id$

/**
 * taxonomy_csv module for Drupal
 *
 * Copyright (c) 2007-2008 Dennis Stevense, see LICENSE.txt for more information
 * Copyright (c) 2009 Daniel Berthereau <daniel.drupal@berthereau.net>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/**
 * @file
 * Quick import of taxonomies, structure or lists of terms from a csv local
 * or distant file or a text area.
 *
 * Automatically imports a list of terms, structure, children, related, synonyms,
 * descriptions and/or weights into a vocabulary with a simple csv file.
 *
 * taxonomy_csv.module contains functions to prepare and submit form.
 * taxonomy_csv.api.inc contains generic functions to import vocabularies.
 */

/**
 * Implements hook_help().
 */
function taxonomy_csv_help($path, $arg) {
  global $language;

  switch ($path) {
    case 'admin/content/taxonomy/csv':
      $output = '<p>'. t('Use this form to import a taxonomy, a structure or a list of terms into a vocabulary from a simple <a href="!link" title="Wikipedia definition">CSV</a> file, a url or a copy-and-paste text.', array('!link' => url('http://en.wikipedia.org/wiki/Comma-separated_values'))) .'</p>';
      $output .= '<p>'. t('For performance reasons, it is recommended to disable some other taxonomy related modules before import of big taxonomies and to reactivate them after process.') .'</p>';
      $output .= '<p>'. t('<strong>Warning:</strong> If you want to update an existing vocabulary, make sure you have a backup before you proceed so you can roll back, if necessary.') . theme('more_help_link', url('admin/help/taxonomy_csv')) .'</p>';
      return $output;

    case 'admin/help#taxonomy_csv':
      $output = file_get_contents(drupal_get_path('module', 'taxonomy_csv') . ((is_file(drupal_get_path('module', 'taxonomy_csv') ."/translations/taxonomy_csv.help.{$language->prefix}.html")) ? "/translations/taxonomy_csv.help.{$language->prefix}.html" : '/taxonomy_csv.help.html'));
      return $output;
  }
}

/**
 * Implements hook_perm().
 */
function taxonomy_csv_perm() {
  return array('administer taxonomy by csv');
}

/**
 * Implements hook_menu().
 *
 * @note See hook_menu for a description of return values.
 */
function taxonomy_csv_menu() {
  $items = array();

  $items['admin/content/taxonomy/csv'] = array(
    'title'            => 'CSV import',
    'page callback'    => 'taxonomy_csv_form',
    'access arguments' => array('administer taxonomy by csv'),
    'weight'           => 12,
    'type'             => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Menu callback of the main import form.
 */
function taxonomy_csv_form() {
  // Invoke taxonomy_csv api (defines and functions).
  $taxonomy_csv_path = drupal_get_path('module', 'taxonomy_csv');
  require_once("$taxonomy_csv_path/taxonomy_csv.api.inc");

  // Javascript and css allow to show only available options depending user's choice.
  drupal_add_js("$taxonomy_csv_path/taxonomy_csv.js");
  drupal_add_css("$taxonomy_csv_path/taxonomy_csv.css");

  return drupal_get_form('taxonomy_csv_form_main');
}

/**
 * Generates the taxonomy CSV import form.
 *
 * Form contain five fieldsets:
 * - 1. What to import ?
 *     1. What is content of the source ?
 * - 2. Where are items to import ?
 *     1. Source choice
 *       1. Source select
 *       2. Source file or text area
 *     2. Source options
 *       1. Source delimiter
 *       2. Source enclosure
 * - 3. Which vocabulary to import into (destination) ?
 *     1. Destination type
 *     2. Vocabulary choice
 * - 4. How to import ?
 *     1. Previous or existing terms
 *     2. Specific import options depending on source content
 * - 5. Advanced options
 *     1. Tweaks for big and specific vocabularies
 *     2. How to be notified
 *
 * As what will become existing terms depends on what is imported, dynamic
 * options are used: only possible parameters are shown. All options are
 * displayed if javascript is not activated.
 *
 * @ingroup forms
 * @see taxonomy_csv_form_main_validate()
 * @see taxonomy_csv_form_main_submit()
 */
function taxonomy_csv_form_main($form_state) {
  // Display main form
  $list_recommended_values = array(
    'source_content'                => TAXONOMY_CSV_SOURCE_ALONE_TERMS,
    'source_choice'                 => 'text',
    'source_delimiter'              => 'comma',
    'source_delimiter_custom'       => '',
    'source_enclosure'              => 'none',
    'source_enclosure_custom'       => '',
    'destination_target'            => 'autocreate',
    'destination_vocabulary_id'     => 'choose_vocabulary', // Not used for security reason (avoid import mistake).
    'import_existing_items'         => TAXONOMY_CSV_EXISTING_UPDATE,
    'relations_create_subrelations' => FALSE,
    'relations_all_vocabularies'    => FALSE,
    'disable_internal_cache'        => FALSE,
    'disable_hierarchy_check'       => FALSE,
    'hierarchy_level'               => 2,
    'disable_line_checks'           => FALSE,
    'disable_utf8_check'            => FALSE,
    'result_stats'                  => 'result_stats',
    'result_terms'                  => 'result_terms',
    'result_level'                  => 'notices',
    'result_type'                   => 'by_message',
  );

  // Remember previous values, for use in particular when reloading form.
  // If not reloading form, then use previous saved value if exists, else recommended value.
  // Warning: specific values 'text', 'path' and 'url are not saved here.
  $list_previous_values = array();
  foreach ($list_recommended_values as $key => $value) {
    $list_previous_values[$key] = isset($form_state['values'][$key]) ? $form_state['values'][$key] : variable_get("taxonomy_csv_{$key}", $value);
  }

  // Needed to clean values of old releases. To be removed.
  $list_previous_values['source_delimiter_custom'] = drupal_substr($list_previous_values['source_delimiter_custom'], 0, 1);
  $list_previous_values['source_enclosure_custom'] = drupal_substr($list_previous_values['source_enclosure_custom'], 0, 1);

  $list_source_content = _taxonomy_csv_info_lists('list_source_content');

  $list_source_delimiters = array(
    'comma'            => t('" , " (Comma)'),
    'semicolon'        => t('" ; " (Semicolon)'),
    'tabulation'       => t('"   " (Tabulation)'),
    'space'            => t('"   " (Space)'),
    'custom_delimiter' => t('Custom delimiter'),
  );

  $list_source_enclosures = array(
    'none'             => t('None'),
    'quotation'        => t('" " " (Quotation mark)'),
    'custom_enclosure' => t('Custom enclosure'),
  );

  $list_destination_targets = array(
    'autocreate' => t('Autocreate a new vocabulary'),
    'duplicate'  => t('Duplicate an existing vocabulary'),
    'existing'   => t('Import in an existing vocabulary'),
  );

  $list_import_options = _taxonomy_csv_info_lists('list_import_options');

  // Build form.
  $form = array(
    '#attributes' => array(
      'enctype' => 'multipart/form-data',
    )
  );

  // Used with recommended values button.
  $form['list']['list_recommended_values'] = array(
    '#type'  => 'value',
    '#value' => $list_recommended_values,
  );

  // Advertise if Pathauto module is activated. Issue http://drupal.org/node/540916.
  if (module_exists('pathauto')) {
    drupal_set_message(t("<strong>Warning</strong>: Pathauto module is activated.<br />This module slows down taxonomy import process and only few terms can be imported. It's advised to disabled it manually in !modules_section. Settings aren't lost when you disable it - and not uninstall it -.<br />After import process, you can reactivate Pathauto and eventually bulk generate aliases for newly imported terms.", array('!modules_section' => l(t("modules section"), 'admin/build/modules'))), 'error');
  }

  $form['import_type'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('1. What do you want to import?'),
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
  );

  $form['import_type']['source_content'] = array(
    '#type'          => 'select',
    '#title'         => '',
    '#options'       => $list_source_content,
    '#default_value' => $list_previous_values['source_content'],
    '#required'      => TRUE,
    '#attributes'  => array('id' => 'source_content'),
  );

  if ($_COOKIE['has_js']) {
    $form['import_type']['description_alone_terms'] = array(
      '#type'        => 'item',
      '#description' => t('Only the term in the first column of each line is imported. Additional columns are ignored.'),
      '#prefix'      => '<div id="description_alone_terms">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_flat'] = array(
      '#type'        => 'item',
      '#description' => t('All items will be imported as terms.'),
      '#prefix'      => '<div id="description_flat">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_tree_structure'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to create a tree structure (geography, classification...).') .'<br />'.
      t('Format: The first term is imported as a root level parent, the second as child of first term, the third as child of second term and so on. The lower child is the last term of a line. Others are hierarchical parents.'),
      '#prefix'      => '<div id="description_tree_structure">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_polyhierarchy'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to create a polyhierarchical structure (genealogy, complex nomenclatures...).') .'<br />'.
      t('Format: The first term is imported as a root level parent, the second as child of first term, the third as child of second term and so on. The lower child is the last term of a line. Others are hierarchical parents.'),
      '#prefix'      => '<div id="description_polyhierarchy">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_parents'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to create a polyhierarchical taxonomy (genealogy...).') .'<br />'.
      t('First item is imported as a term and next ones as parents of first term. Unlike structure import, all parents are first level parents.'),
      '#prefix'      => '<div id="description_parents">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_children'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to create a polyhierarchical taxonomy (genealogy...).') .'<br />'.
      t('First item is imported as a term and next ones as children of first term. Unlike structure import, all children are first level children.'),
      '#prefix'      => '<div id="description_children">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_relations'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to create relations between the term in the first column and next terms of the line.'),
      '#prefix'      => '<div id="description_relations">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_fields'] = array(
      '#type'        => 'item',
      '#description' => t('Import a full term definition') .'<br />'.
      t('Format: term name, weight, description, list of synonyms.'),
      '#prefix'      => '<div id="description_fields">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_descriptions'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to import descriptions of terms. The term is in the first column and the matching description is in the second column.'),
      '#prefix'      => '<div id="description_descriptions">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_weights'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to import a weight of a term. The term is in the first column and the matching weight is in the second column.'),
      '#prefix'      => '<div id="description_weights">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_synonyms'] = array(
      '#type'        => 'item',
      '#description' => t('Allow to import synonyms of terms. Each line contains a term in the first column and next items are matching synonyms.'),
      '#prefix'      => '<div id="description_synonyms">',
      '#suffix'      => '</div>',
    );
    $form['import_type']['description_manager_export'] = array(
      '#type'        => 'item',
      '#description' => t("Allow to import a vocabulary exported with Taxonomy manager.<br/>
      Each line contains: vocabulary id, term id, term name, term description and list of parents. In this format, order of all lines is important, because it's impossible to attach a parent to an item if this parent hasn't been imported in a previous line."),
      '#prefix'      => '<div id="description_manager_export">',
      '#suffix'      => '</div>',
    );
  }
  $form['import_type']['info'] = array(
    '#type'        => 'item',
    '#description' => t('Notice: currently, vocabulary structure is recommended to be imported first when multiple files are imported (with flat, tree structure, polyhierarchy, parents or children choice). See <a href="!more_help_link">advanced help</a> for informations about types.', array('!more_help_link' => url('admin/help/taxonomy_csv'))),
  );

  $form['source'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('2. Where are items to import?'),
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#attributes'  => array('id' => 'edit-source'),
  );

  $form['source']['source_choice'] = array(
    '#type'          => 'select',
    '#title'         => '',
    '#options'       => array(
      'text' => t('In the below text area'),
      'path' => t('In a local file'),
      'url'  => t('In a distant file'),
    ),
    '#default_value' => $list_previous_values['source_choice'],
  );

  $form['source']['text'] = array(
    '#type'          => 'textarea',
    '#title'         => t('Terms to import'),
    '#rows'          => 3,
    '#cols'          => 80,
    '#default_value' => isset($form_state['values']['text']) ? $form_state['values']['text'] : '',
    '#description'   => t('Write your csv formated terms directly in this text area.'),
  );

  $form['source']['path'] = array(
    '#type'          => 'file',
    '#title'         => t('CSV file'),
    '#description'   => t('Browse to the file') .'<br >'. (($max_size = parse_size(ini_get('upload_max_filesize'))) ? t('Due to server restrictions, the <strong>maximum upload file size is !max_size</strong>. Files that exceed this size will be disregarded.', array('!max_size' => format_size($max_size))) : ''),
  );

  $form['source']['url'] = array(
    '#type'          => 'textfield',
    '#title'         => t('CSV file'),
    '#description'   => t('Enter the url (http, ftp, file, path...)') .'<br >'. (($max_size = parse_size(ini_get('upload_max_filesize'))) ? t('Due to server restrictions, the <strong>maximum upload file size is !max_size</strong>. Files that exceed this size will be disregarded.', array('!max_size' => format_size($max_size))) : ''),
  );

  $form['source']['source_advanced'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('Advanced source settings (delimiter and enclosure)'),
    '#description' => t('Notice: either you import terms by a file or by a text area, the csv format is the same. Default delimiter is a comma ("<strong><code> , </code></strong>"). Default enclosure is none, but quotation mark ("<strong><code> " </code></strong>") is automatically managed.'),
    '#collapsible' => TRUE,
    '#collapsed'   => (
      ($list_previous_values['source_delimiter'] == $list_recommended_values['source_delimiter'])
      && ($list_previous_values['source_enclosure'] == $list_recommended_values['source_enclosure'])),
  );

  $form['source']['source_advanced']['source_delimiter'] = array(
    '#type'          => 'select',
    '#title'         => t('CSV value delimiter'),
    '#options'       => $list_source_delimiters,
    '#default_value' => $list_previous_values['source_delimiter'],
    '#description'   => t("Choose the delimiter used in the CSV file you want to import. Tabulation can't be used with text area import."),
  );

  $form['source']['source_advanced']['source_delimiter_custom'] = array(
    '#type'          => 'textfield',
    '#title'         => '',
    '#default_value' => $list_previous_values['source_delimiter_custom'],
    '#size'          => 2,
    '#maxlength'     => 1,
  );

  $form['source']['source_advanced']['source_enclosure'] = array(
    '#type'          => 'select',
    '#title'         => t('CSV value enclosure'),
    '#options'       => $list_source_enclosures,
    '#default_value' => $list_previous_values['source_enclosure'],
    '#description'   => t('Choose the enclosure used in the CSV file you want to import.'),
  );

  $form['source']['source_advanced']['source_enclosure_custom'] = array(
    '#type'          => 'textfield',
    '#title'         => '',
    '#default_value' => $list_previous_values['source_enclosure_custom'],
    '#size'          => 2,
    '#maxlength'     => 1,
  );

  $form['destination'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('3. Which vocabulary do you want to import into?'),
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#description' => t('Terms can be imported into a new vocabulary or in an existing one. You can choose to duplicate an existing vocabulary too in order to check import. You might want to !add-new-vocab.', array(
      '!add-new-vocab' => l(t('add a new vocabulary'), 'admin/content/taxonomy/add/vocabulary', array('query' => drupal_get_destination())),
    )),
    '#attributes'  => array('id' => 'edit-destination'),
  );

  $list_vocabularies = taxonomy_get_vocabularies();

  if (count($list_vocabularies) == 0) {
    $form['destination']['#description'] .= '<br />'. t("As there isn't any vocabulary, terms will be imported in a new automatically created vocabulary.");

    $form['destination']['destination_target'] = array(
      '#type'  => 'value',
      '#value' => 'autocreate',
    );
  }
  else {
    $form['destination']['destination_target'] = array(
      '#type'          => 'select',
      '#options'       => $list_destination_targets,
      '#default_value' => $list_previous_values['destination_target'],
      '#description'   => t('
        When you want to import a new taxonomy into an existing one, it is recommended to process in three steps in order to allow a good import.
        <ul>
          <li>First, check the import file with the < <em>Autocreate a new vocabulary</em> > option. Repeat this step while there are warnings and notices.</li>
          <li>Second, check new and existing terms merge with the < <em>Duplicate an existing vocabulary</em> > option. This choice creates a duplicate of your target existing vocabulary and import your new terms into. Original nodes attachments are not duplicated.</li>
          <li>Finally, you can import your file in the true vocabulary with the < <em>Import in an existing vocabulary</em> > option. This allows you to keep old links between existing terms and nodes.</li>
        </ul>
        If you only want to create a new vocabulary, the first choice is sufficient, unless when you have multiple files for one vocabulary.'),
    );

    $form['destination']['destination_vocabulary_id'] = array(
      '#type'          => 'select',
      '#title'         => t('Vocabulary choice'),
      '#options'       => array(
        'choose_vocabulary' => t('[Choose an existing vocabulary]')
      ),
      '#default_value' => 'choose_vocabulary',
      '#description'   => t('The vocabulary you want to import the file into.'),
    );
    foreach ($list_vocabularies as $vid => $vocabulary) {
      $form['destination']['destination_vocabulary_id']['#options'][$vid] = $vocabulary->name;
    }
  }

  $form['import_options'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('4. How to import your terms?'),
    '#required'    => TRUE,
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
  );

  $form['import_options']['import_existing_items'] = array(
    '#type'          => 'radios',
    '#title'         => t('What will existing or previous imported terms become when a term with same name will be imported?'),
    '#default_value' => $list_previous_values['import_existing_items'],
    '#description'   => t('This option allows to set what previous imported terms will become if a new line contains the same terms. Usually, it indicates an error or a unoptimized source, unless you allow duplicates.<br />
    This option is used too with existing terms in the target vocabulary. Recommended value is to update and merge. If you choose to ignore previous or existing terms, the vocabulary will have duplicate terms.<br />
    Some choices may be currently disabled.'),
  );
  if ($_COOKIE['has_js']) {
    // Store full list of generic import_existing_items and set only the correct one in order to keep all options possible with javascript and css.
    $form['import_options']['import_existing_items']['#options'] = $list_import_options;

    // Descriptions and examples of the option import_existing_items option.
    $form['import_options']['help_alone_terms'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Alone terms)'),
      '#description' => t('This option indicates whether existing terms with the same name should be updated or ignored. If ignored, duplicates may be created.'),
      '#prefix'      => '<div id="help_alone_terms">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_flat'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Terms)'),
      '#description' => t('This option indicates whether existing terms with the same name should be updated or ignored. If ignored, duplicates may be created.'),
      '#prefix'      => '<div id="help_flat">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_tree_structure'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Tree structure)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.<br />
      This option is used with last term of the line.') .'<br />'.
      t('<ul>
          <li><em>"Update and replace"</em>: each parent replaces eventual older ones.</li>
          <li><em>"Ignore and create"</em>: child is always created and eventually its parents if they don\'t exist.</li>
          <li><em>"Ignore and create all"</em>: Child and its parents are always created, even if they already exist. Duplicates may be created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_tree_structure">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_polyhierarchy'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Polyhierarchy)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.
      t('By nature, only one option can be chosen with this format.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: each child and parents are merged with old ones, except if the child has the same name than parent, in which case a new term is created, because a child cannot be a parent of itself. Warning: on next lines, direct children of this term name will be attached to the first imported term.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_polyhierarchy">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_parents'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (First level parents of a list of terms)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: each child and parents are merged with old ones. No duplicate are created.</li>
          <li><em>"Update and replace"</em>: each parent replaces eventual older ones.</li>
          <li><em>"Ignore and create"</em>: child is always created and eventually its parents if they don\'t exist.</li>
          <li><em>"Ignore and create all"</em>: Child and its parents are always created, even if they already exist. Duplicates may be created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_parents">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_children'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (First level children of a list of terms)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: each child and parents are merged with old ones.</li>
          <li><em>"Update and replace"</em>: each parent replaces eventual older ones.</li>
          <li><em>"Ignore and create"</em>: child is always created and eventually its parents if they don\'t exist.</li>
          <li><em>"Ignore and create all"</em>: Child and its parents are always created, even if they already exist. Duplicates may be created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_children">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_relations'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Related terms)'),
      '#description' => t('This option indicates whether existing terms with the same name should be updated or ignored.
        <p>For example, if existing related terms of term < <code>Drupal</code> > are < <code>Free</code> > and < <code>Open source</code> > and an imported line in the csv file is < <code>"Drupal","Knowledge management","Free"</code> >, then:') .'<br >'.
        t('<ul>
          <li><em>"Update and merge"</em> choice makes related terms of < <code>Drupal</code> > are now < <code>Free</code> >, < <code>Open source</code> > and < <code>Knowledge management</code> >;</li>
          <li><em>"Update and replace"</em> choice makes related terms of < <code>Drupal</code> > are now < <code>Knowledge management</code> > and < <code>Free</code> >;</li>
          <li><em>"Ignore and create"</em> choice makes two < <code>Drupal</code> > terms, one with existing related and other items and another one with the imported related terms < <code>Knowledge management</code> > and < <code>Free</code> >, which one has not been duplicated;</li>
          <li><em>"Ignore and create all"</em> choice makes two < <code>Drupal</code> > as previously, but create too related term < <code>Free</code> > even if it exist.</li>
        </ul></p>'
      ),
      '#prefix'      => '<div id="help_relations">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_fields'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Full term definition)'),
      '#description' => t('This option indicates whether existing terms with the same name should be updated or ignored. If ignored, duplicates may be created.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: update term or create it if not exists and merge eventual description with new one.</li>
          <li><em>"Update and replace"</em>: update term or create it if not exists and replace eventual description with new one.</li>
          <li><em>"Ignore and create"</em>: term is always created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_fields">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_descriptions'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Descriptions)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: update term or create it if not exists and merge eventual description with new one.</li>
          <li><em>"Update and replace"</em>: update term or create it if not exists and replace eventual description with new one.</li>
          <li><em>"Ignore and create"</em>: term is always created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_descriptions">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_weights'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Weights)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.'),
      '#prefix'      => '<div id="help_weights">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_synonyms'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Synonyms)'),
      '#description' => t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.
      t('<ul>
          <li><em>"Update and merge"</em>: update term or create it if not exists and merge eventual synonyms with new ones. Always remove duplicate synonyms.</li>
          <li><em>"Update and replace"</em>: update term or create it if not exists and replace eventual synonyms with new ones.</li>
          <li><em>"Ignore and create"</em>: term is always created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_synonyms">',
      '#suffix'      => '</div>',
    );
    $form['import_options']['help_manager_export'] = array(
      '#type'        => 'item',
      '#value'       => t('Additional help (Taxonomy manager export)'),
      '#description' => t("When a vocabulary is imported in an existing one, only third option (ignore existing terms) can be used.") .'<br />'.
      t('This option indicates whether and how existing terms with the same name should be updated or ignored.') .'<br />'.        t('<ul>
          <li><em>"Update and merge"</em>: update term or create it if not exists and merge eventual parents with new ones.</li>
          <li><em>"Update and replace"</em>: update term or create it if not exists and replace eventual parents with new ones.</li>
          <li><em>"Ignore and create"</em>: term is always created.</li>
        </ul>'
      ),
      '#prefix'      => '<div id="help_manager_export">',
      '#suffix'      => '</div>',
    );
  }
  else {
    // Use this form only if no javascript (or, in a next evolution, in a second step wizard).
    $form['import_options']['#description'] = '<br />'. t("As you see this notice, javascript is not activated on your browser. Only options matching your source content and vocabulary destination needs to be set. Others won't be used. If you want specific examples and options, activate javascript or see <a href=\"!more_help_link\"> advanced help</a>.", array('!more_help_link' => url('admin/help/taxonomy_csv')));

    $form['import_options']['import_existing_items']['#options'] = array_intersect_key($list_import_options, array_flip(array(
      TAXONOMY_CSV_EXISTING_UPDATE,
      TAXONOMY_CSV_EXISTING_UPDATE_MERGE,
      TAXONOMY_CSV_EXISTING_UPDATE_REPLACE,
      TAXONOMY_CSV_EXISTING_IGNORE,
      TAXONOMY_CSV_EXISTING_IGNORE_CREATE,
      TAXONOMY_CSV_EXISTING_IGNORE_ALL,
    )));
  }

  // Specific options to import relations.
  $form['import_options']['relations'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('Specific settings of related terms'),
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#description' => t('Set these options only if you import related terms'),
    '#attributes'  => array('id' => 'edit-relations'),
  );
  $form['import_options']['relations']['relations_create_subrelations'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Import subrelations'),
    '#default_value' => $list_previous_values['relations_create_subrelations'],
    '#description'   => t('This checkbox allows to import subrelations of related terms and not only relations of first column term with others.
    <p>For example, with the line < <code>"Paris","London","Bern","Roma"</code> >, default import is to make a link between < <code>Paris</code> > and each of three terms. There is no link between < <code>London</code> > and < <code>Bern</code> > neither < <code>Roma</code> >. Checking this option creates not only relations with first term, but all subrelations too: < <code>London</code> > and < <code>Bern</code> >, < <code>London</code> > and < <code>Roma</code> > and finally < <code>Bern</code> > and < <code>Roma</code> >.</p>'),
  );
  // Internal use only.
  $form['import_options']['relations']['relations_all_vocabularies'] = array(
    '#type'          => 'value',
    '#title'         => t('Make relations with existing terms of all vocabularies'),
    '#default_value' => $list_previous_values['relations_all_vocabularies'],
    '#description'   => t("This checkbox allows to create relations with existing terms in other vocabularies if they don't exist in selected vocabulary."),
    '#disabled'      => TRUE,
  );

  $form['advanced_options'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('5. Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#attributes'  => array('id' => 'advanced_options'),
  );

  $form['advanced_options']['tweaks'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('Tweaks for big or specific vocabularies'),
    '#collapsible' => TRUE,
    '#collapsed'   => (
      ($list_previous_values['disable_internal_cache'] == $list_recommended_values['disable_internal_cache'])
      && ($list_previous_values['disable_hierarchy_check'] == $list_recommended_values['disable_hierarchy_check'])
      && ($list_previous_values['disable_line_checks'] == $list_recommended_values['disable_line_checks'])
      && ($list_previous_values['disable_utf8_check'] == $list_recommended_values['disable_utf8_check'])
    ),
  );

  $form['advanced_options']['tweaks']['disable_internal_cache'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Disable internal cache'),
    '#default_value' => $list_previous_values['disable_internal_cache'],
    '#description'   => t("To disable internal cache allows to import vocabularies of any size. Internal cache is used to speed up process, to reduce access to sql base an to be informed about process. When disabled, no information about results can be displayed except eventual first error or warning.<br />
    It's recommended to disable cache if the imported vocabulary is too big (more than 1000 to 10000 lines on current systems), because it avoids memory congestion on server."),
  );

  $form['advanced_options']['tweaks']['disable_hierarchy_check'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Manually set vocabulary hierarchy'),
    '#default_value' => $list_previous_values['disable_hierarchy_check'],
  );
  $form['advanced_options']['tweaks']['hierarchy_level'] = array(
    '#type'          => 'radios',
    '#title'         => '',
    '#options'       => _taxonomy_csv_info_lists('hierarchy_text'),
    '#default_value' => $list_previous_values['hierarchy_level'],
    '#prefix'        => '<div id="hierarchy_level">',
    '#suffix'        => '</div>',
  );
  $form['advanced_options']['tweaks']['vocabulary_hierarchy_info'] = array(
    '#type'          => 'item',
    '#value'         => '',
    '#description'   => t('Because to calculate vocabulary hierarchy is memory intensive, this option allows to set hierarchy manually without verify it.'),
  );

  $form['advanced_options']['tweaks']['disable_line_checks'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Disable line checks'),
    '#default_value' => $list_previous_values['disable_line_checks'],
    '#description'   => t('If you are sure that vocabulary to import is well formated (utf8, order of items...), you can disable checks.'),
  );

  $form['advanced_options']['tweaks']['disable_utf8_check'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Disable file conversion to UTF-8'),
    '#description'   => t('This checkbox allows to disable convert to UTF-8, what can resolve problems with some rare server configurations. Be sure your file is UTF-8 encoded when disabling this option. This option is not used with a textarea import.'),
  );
  if (function_exists('mb_detect_encoding')) {
    $form['advanced_options']['tweaks']['disable_utf8_check']['#default_value'] = $list_previous_values['disable_utf8_check'];
  }
  else {
    $form['advanced_options']['tweaks']['disable_utf8_check']['#default_value'] = TRUE;
    $form['advanced_options']['tweaks']['disable_utf8_check']['#disabled'] = TRUE;
    $form['advanced_options']['tweaks']['disable_utf8_check']['#description'] .= '<br />'. t('This checkbox is currently disabled, because iconv, GNU recode or mbstring for PHP are not installed on your server.');
  }

  $form['advanced_options']['result_display'] = array(
    '#type'        => 'fieldset',
    '#title'       => t('Results informations to display'),
    '#collapsible' => TRUE,
    '#collapsed'   => (
      ($list_previous_values['result_stats'] == $list_recommended_values['result_stats'])
      && ($list_previous_values['result_terms'] == $list_recommended_values['result_terms'])
      && ($list_previous_values['result_level'] == $list_recommended_values['result_level'])
      && ($list_previous_values['result_type'] == $list_recommended_values['result_type'])
    ),
  );

  $form['advanced_options']['result_display']['result_display_cache'] = array(
    '#type'        => 'item',
    '#description' => t('Except first warning, no information can be displayed when internal cache is disabled.'),
    '#prefix'      => '<div id="result_display_cache">',
    '#suffix'      => '</div>',
  );

  $form['advanced_options']['result_display']['result_choices'] = array(
    '#type'          => 'checkboxes',
    '#options'       => array(
      'result_stats'    => t('Basic stats on imported terms'),
      'result_terms'    => t('List of imported terms'),
    ),
    '#default_value' => array(
      $list_previous_values['result_stats'],
      $list_previous_values['result_terms'],
    ),
    '#prefix'        => '<div id="result_display_options">',
  );

  $form['advanced_options']['result_display']['result_level'] = array(
    '#type'          => 'radios',
    '#title'         => t('Log level'),
    '#options'       => array(
      'none'     => t('Only first warning'),
      'warnings' => t('Warnings'),
      'notices'  => t('Warnings and notices'),
      'infos'    => t('Warnings, notices and informations'),
//      'full'     => t('Errors, warnings, notices and informations for each term'),
    ),
    '#default_value' => $list_previous_values['result_level'],
  );

  $form['advanced_options']['result_display']['result_type'] = array(
    '#type'          => 'radios',
    '#title'         => t('Group warnings'),
    '#options'       => array(
      'by_message'  => t('By message (compact view)'),
      'by_line'     => t('By line (list view)'),
//       'by_collapse' => t('Group warnings and notices by line (collapsible view)'),
    ),
    '#default_value' => $list_previous_values['result_type'],
    '#prefix'        => '<div id="result_type">',
    '#suffix'        => '</div>',
  );

  $form['advanced_options']['result_display']['result_info'] = array(
    '#type'        => 'item',
    '#description' => t('Warning: display warnings, notices and informations, especially by line, can help you to detect issues when submitted list of terms is not clean, but it may be memory intensive.'),
    '#suffix'      => '</div>',
  );

  $form['import_submit'] = array(
    '#type'  => 'submit',
    '#value' => t('Import'),
  );

  $form['recommended_values_submit'] = array(
    '#type'     => 'submit',
    '#value'    => t('Default values'),
    '#validate' => array('_taxonomy_csv_form_recommended_values'),
  );

  return $form;
}

/**
 * Handles CSV import form validation.
 *
 * @see taxonomy_csv_form()
 */
function taxonomy_csv_form_main_validate($form, &$form_state) {
  $options = &$form_state['values'];

  // Load source local file. Check is made by Api.
  // 'url' and 'text' are loaded and checked by Api.
  if ($options['source_choice'] == 'path') {
    $options['file'] = file_save_upload('path');
  }
  //  Clean textarea in order to decrease memory usage.
  if ($options['source_choice'] != 'text') {
    $options['text'] = '';
  }

  // Define true delimiter.
  switch ($options['source_delimiter']) {
    case 'semicolon':
      $options['delimiter'] = ';';
      break;
    case 'tabulation':
      $options['delimiter'] = "\t";
      break;
    case 'space':
      $options['delimiter'] = " ";
      break;
    case 'custom_delimiter':
      $options['delimiter'] = $options['source_delimiter_custom'];
      break;
    case 'comma':
    default:
      $options['delimiter'] = ',';
  }

  // Define true enclosure.
  switch ($options['source_enclosure']) {
    case 'quotation':
      $options['enclosure'] = '"';
      break;
    case 'custom_enclosure':
      $options['enclosure'] = $options['source_enclosure_custom'];
      break;
    case 'none':
    default:
      $options['enclosure'] = '';
  }

  // API checks and eventually update options.
  $messages = _taxonomy_csv_vocabulary_import_check_options($options);

  // Non API checks.
  if (($options['source_delimiter'] == 'custom_delimiter')
      && (empty($options['source_delimiter_custom']))) {
    $messages['source_delimiter_custom'] = t('You choose to use a custom delimiter, but your delimiter is empty.');
  }

  if (($options['source_enclosure'] == 'custom_enclosure')
      && (empty($options['source_enclosure_custom']))) {
    $messages['source_enclosure_custom'] = t('You choose to use a custom enclosure, but your enclosure is empty.');
  }

  if (($options['source_delimiter'] == 'custom_delimiter')
      && (drupal_strlen($options['source_delimiter_custom']) > 1)) {
    $messages['source_delimiter_custom'] = t('Delimiter should have only one character.');
  }
  if (($options['source_enclosure'] == 'custom_enclosure')
      && (drupal_strlen($options['source_enclosure_custom']) > 1)) {
    $messages['source_enclosure_custom'] = t('Enclosure should have only zero or one character.');
  }

  // Validate form.
  foreach ($messages as $item => $message) {
    if (in_array($item, $options)) {
      form_set_error($item, $message);
    }
    else {
      drupal_set_message($message, 'error');
    }
  }
}

/**
 * Handles CSV import form submission and launch batch set.
 *
 * @see taxonomy_csv_form()
 */
function taxonomy_csv_form_main_submit($form, &$form_state) {
  // Remember last preferences and prepare options to be sent to Api.
  foreach (array(
      'source_content',
      'source_choice',
      'source_delimiter',
      'source_delimiter_custom',
      'source_enclosure',
      'source_enclosure_custom',
      'destination_target',
      'destination_vocabulary_id',
      'import_existing_items',
      'relations_create_subrelations',
      'relations_all_vocabularies',
      'disable_internal_cache',
      'disable_hierarchy_check',
      'hierarchy_level',
      'disable_line_checks',
      'disable_utf8_check',
      'result_level',
      'result_type',
    ) as $option) {
    variable_set("taxonomy_csv_$option", $form_state['values'][$option]);
    $options[$option] = $form_state['values'][$option];
  }
  // Remember last preferences (['result_choices'] checkboxes).
  foreach (array(
      'result_stats',
      'result_terms',
    ) as $option) {
    variable_set("taxonomy_csv_$option", $form_state['values']['result_choices'][$option]);
    $options[$option] = $form_state['values']['result_choices'][$option];
  }
  // Finish to prepare $options. Unset useless options for api.
  $options['internal_cache'] = !$options['disable_internal_cache'];
  $options['hierarchy_check'] = !$options['disable_hierarchy_check'];
  $options['line_checks'] = !$options['disable_line_checks'];
  $options['utf8_check'] = !$options['disable_utf8_check'];
  unset($options['disable_internal_cache']);
  unset($options['disable_hierarchy_check']);
  unset($options['disable_line_checks']);
  unset($options['disable_utf8_check']);
  $options['delimiter'] = $form_state['values']['delimiter'];
  $options['enclosure'] = $form_state['values']['enclosure'];
  unset($options['source_delimiter']);
  unset($options['source_delimiter_custom']);
  unset($options['source_enclosure']);
  unset($options['source_enclosure_custom']);
  if ($options['source_choice'] == 'text') {
    $options['text'] = &$form_state['values']['text'];
  }
  else {
    $options['file'] = &$form_state['values']['file'];
  }
  unset($form_state['values']['text']);
  unset($form_state['values']['file']);

  if (function_exists('taxonomy_csv_vocabulary_import')) {
    // Prepares process batch (will be automatically processed when returns).
    taxonomy_csv_vocabulary_import($options);
  }
  else {
    drupal_set_message(t('Taxonomy_csv Api cannot be loaded. Please reinstall module.'), 'error');
  }

  // Reinitialize choices.
  unset($form_state['values']);
  unset($form_state['storage']);
  $form_state['rebuild'] = TRUE;
}

/**
 * Restore recommended default values in the import form.
 */
function _taxonomy_csv_form_recommended_values($form, &$form_state) {
  foreach ($form_state['values']['list_recommended_values'] as $option => $value) {
    variable_set("taxonomy_csv_$option", $value);
  }
  unset($form_state['values']);
  unset($form_state['storage']);
  $form_state['rebuild'] = TRUE;
}
